---
title: "SICP 맛만 본 후기"
date: "2025-04-24"
hidden: true
---

"튜닝의 끝은 순정이라고 했던가. 초심으로 돌아가고 싶다."

지금까지 CS를 4년 동안 전공하면서 C부터 시작해 다양한 언어를 배우고, 자료구조를 배우고, 프레임워크도 이것저것 다뤄봤다.

어느 순간, 내가 배우는 게 단순히 '도구'를 익히는 데 그치고 있다는 생각이 들었다.

물론 필요한 일이다.

하지만 왜 이런 도구들이 생겨났고, 어떤 문제의식에서 이런 개념들이 만들어졌는지를 모른 채 그저 단순히 도구를 배워나가는 과정이 나를 점점 지치게 만들었다.

> 누군가 열심히 조각내둔 레고를 설명서 보고 손가락으로 대충 까딱 해서 맞추는 느낌이랄까

뭔가 공감 없이 쌓아가는 지식은 금방 의미를 잃는 것 같았다.

나는 '어떻게'보다는 '왜'라는 질문에 답하고 싶었던 것 같다.

![1](1.png)

그러다 우연히 《SICP: Structure and Interpretation of Computer Programs》 번역본 책을 접하게 됐다.

전부 꼼꼼히 읽어본 것은 아니다. 그저 프로그래밍의 본질이 뭔지, 그 이면에는 무엇이 존재하는지가 궁금했을 뿐이니까.

## 추상화

![2](2.png)

> 아 이건 Abstract art고 앞으로 말할 추상화는 Abstraction이긴 하다.

추상화. 어떻게 보면 프로그래밍의 본질을 꿰뚫는 말이지 않을까 싶다.

"프로그래밍이란 계산 과정을 구성하고 표현하는 작업이며, 그 **핵심**은 추상화를 만들어내고 계층적으로 쌓아가는 일"이라고 한다.

즉, 프로그래밍은 사고의 구조를 구체화하는 작업이라는 것.

> 뭔가 철학적인 말들이 멋있다,,

### 프로시저 추상화

> 프로시저는 연산을 추상화한 것이다.

어떤 계산을 수행할 때, 그것을 하나의 이름으로 감싸고, 내부의 구체적인 구현은 감춘다. 우리는 그 함수가 어떻게 작동하는지를 모르더라도, 이름과 입력만으로 '무엇을 하는지' 이해할 수 있다.

```scheme
(define (square x) (* x x))
```

우리는 `square`가 내부적으로 곱셈을 사용하는지, 루프를 도는지 신경 쓰지 않는다.

중요한 건, 이 함수가 '제곱'이라는 의미 있는 연산을 추상화했다는 점이다.

- "무엇을 하는가"는 중요하고, "어떻게 하는가"는 감출 수 있다.
- 절차를 이름으로 감싸서 높은 수준의 표현을 가능하게 한다.

### 데이터 추상화

> 데이터는 우리가 정의한 연산에 의해 의미를 가진다.

"자료 구조를 직접 정의하고, 그것을 조작하는 연산(인터페이스)을 만드는 것"이 바로 추상화라고 말한다. 중요한 것은 데이터가 어떤 형식으로 저장되느냐가 아니라, 어떤 연산으로 접근되느냐이다.

```scheme
(define (real-part z) ...)
(define (imag-part z) ...)
(define (magnitude z) ...)
```

사용자는 z가 어떤 방식으로 저장되었는지 몰라도 연산을 사용할 수 있다.

- 데이터를 하나의 의미 있는 개념으로 만들고, 그것을 통해 구조를 이해하게 한다
- 데이터는 하나의 표현(Representation)이 아닌 추상적인 역할(Role)로 보아야 한다

### 계층적 추상화

추상화는 반복적으로 쌓인다. 그리고 그 반복의 결과가 복잡한 프로그램이 되는 것이다.

단순한 함수 -> 복잡한 함수 조합 -> 데이터 타입 -> 언어 구성 요소 -> 언어 자체

함수를 만들고, 그 위에 더 복잡한 함수를 만들고, 자료 구조를 정의하고, 그 위에 의미 있는 연산을 얹는다. 이 모든 것들이 층층이 쌓이면서 하나의 시스템을 만든다.

결국, "추상화"라는 것은 복잡함을 계층화해 더욱 복잡한 것을 다룰 수 있도록 만든다.

## 함수형 프로그래밍

프로그래밍 패러다임을 찾다 보면 함수형 프로그래밍이 등장한다.

사람들은 대개 이 패러다임을 일대일의 관계로 생각하여 서로 비교하고 뭐가 좋은 건지 나쁜 건지 결론을 내리는데 이건 절대 아니다.

언어는 여러 패러다임의 성격을 가지기도 한다. 요즘 언어는 다 하나 이상의 패러다임을 따라간다.

SICP에서 함수형 프로그래밍이 등장한다. 그 배경에는 "프로그래밍의 본질"과 "추상화"를 제일 잘 드러내는 방식이기 때문이지 않을까 생각한다.

### 순수 함수

함수에게 같은 값이 주어졌을 때 항상 같은 값을 배출한다.

- 항상 같은 입력 -> 같은 출력
- 외부 상태에 의존하거나, 외부 상태를 변경하지 않아야 함

누가 보면 당연한 소리겠지만 실상은 그렇지 않다.

```c
int variable_from_outside = 10;

int doSomething(int x) {
  int y = variable_from_outside;
  return x + y;
}
```

명백히 위배된다.

`doSomething` 함수는 외부 변수인 `variable_from_outside`에 의존하고 있기 때문에 항상 같은 input인 `x`를 넣더라도 output은 바뀔 수 있는 가능성이 있다.

### 고차 함수

함수를 인자의 값으로 사용하거나 함수를 반환할 수 있다.

```javascript
function applyTwice(f, x) {
  return f(f(x));
}

function double(n) {
  return n * 2;
}

console.log(applyTwice(double, 3));

function adder(added) {
  return function (num) {
    return num + added;
  };
}

const add = adder(3);
const output = add(2);
console.log(output);
```

`applyTwice` 함수에 `double` 함수를 인자 값으로 넘겨주었다.

`adder` 함수는 num + added의 값을 더하는 함수를 반환하고 있다.

### 1급 시민

1급 시민이라는 말이 많이 생소한데 뜻은 아주 가볍다.

함수를 그저 데이터처럼 값으로 사용한다는 것이다.

```javascript
const sayHello = function () {
  console.log("Hello!");
};

const funcs = [sayHello, Math.sqrt];
```

`sayHello` 함수를 변수로 선언했고, 배열의 값에 넣었다.

함수를 값처럼 다룰 수 있어야 한다.

### 모로 가도 서울만 가면 된다

요즘은 Javascript를 많이 하게 되는데 함수형 프로그래밍 특징을 많이 쓴다.

JSX의 prop이라고 부르는 곳에 함수를 넘겨준다던지, filter, map, forEach 등 수많은 곳에 함수를 값으로 넘겨주기도 한다.

외에도 SwiftUI를 하다 보면 클로저 지옥에 빠지는데 이것도 함수형 프로그래밍의 특징이기도 하다.

## 나의 생각

철학적인 생각을 많이 하게 된다.

프로그래밍이라는 걸 0과 1의 시각이 아닌, 조금은 사람의 관점에서 바라볼 수 있게 되지 않았을까 싶다.

그저 수학 공식으로 시작해서 현대를 이끌어가는 프로그래밍이란.

> 여전히 글 쓰는 재주가 없는 것 같다. 어릴 때 책 좀 많이 읽으라던 어른들의 잔소리가 스쳐 지나간다. 글에 여전히 기승전결이 없지만 앞으로 많이 발전할 나를 위해.
