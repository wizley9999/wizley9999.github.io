---
title: "페이지 교체 알고리즘 FIFO, LRU, LFU 계산 방법"
date: "2025-07-09"
hidden: true
---

정처기 실기 공부한다. 음,, 어떻게 공부해야 할지 전혀 모르겠지만 뭐라도 해야겠지?

OS 파트 중에 메모리 관리 기법에 관한 내용이 있다. 어차피 가상메모리 체계로 동작하는지라 실제로도 페이징 기법을 사용할 것 같은데 이 페이징 기법에 관한 알고리즘 문제가 종종 나오는 것 같아서 이 알고리즘을 이용한 계산 방법을 써보고자 한다.

가상메모리는 램 + 디스크 저장 공간을 합친 것처럼 동작한다. (맥에서는 따로 스왑 공간이라고 부르는 것 같다.) 프로세스가 차지하는 메모리 중에 현재 사용하지 않고 있는 부분은 디스크 공간으로 일부를 보내버리고 당장 메모리에서 사용할 부분들을 실제 메모리에 적재하는 방식으로 운용이 된다.

디스크 공간으로 "일부"를 보내버린다고 했는데 이를 페이징 기법이라고 한다. 페이징은 간단하다. 프로세스가 사용하는 메모리를 세세하게 쪼개서 하나의 페이지 단위로 만들고 이 페이지를 디스크에 넣고 빼고를 반복한다고 보면 된다.

> 장점은 외부 단편화(블록 공간이 부족한)는 발생할 일이 없고 내부 단편화(블록 공간이 남는)도 페이지 단위로 쪼개놔서 발생하더라도 그 규모가 크지 않다는 점?

이 페이지를 교체할 때 페이지 테이블을 참조하면서 교체를 하는데 그 방식 중에 여러가지 알고리즘이 존재하고 대표적으로 시험에 자주 나오는 FIFO, LRU, LFU를 소개한다.

> 페이지 부재(Page Fault)는 다음 페이지 순서가 프레임에 없는 상태라 교체 작업이 이루어져야 하는 상태를 의미한다. 반대로 페이지 히트(Page Hit)는 다음 페이지 순서가 프레임에 존재하기 때문에 교체 작업이 필요 없는 상태다.

## FIFO

스택이다 스택. First In First Out.

페이지를 교체할 때 메모리에 먼저 차지하고 있던 페이지를 내보내고 새로운 걸로 교체한다.

3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태와 페이지 부재 횟수를 쓰시오.

[_ _ _] <- 이게 프레임 상태

[1(1) _ _] <- Page Fault (부재 발생), (1)은 얼마나 오래 됐는지 기록하는 용도이다.

[1(2) 2(1) _] <- Page Fault

[1(3) 2(2) _] <- Page Hit (1이 이미 있어서)

[1(4) 2(3) 0(1)] <- Page Fault

[2(4) 0(2) 4(1)] <- Page Fault (가장 오래된 1이 빠지고 하나씩 앞으로 당겼다)

[0(3) 4(2) 1(1)] <- Page Fault

[4(3) 1(2) 3(1)] <- Page Fault

최종 상태: [4 1 3]

부재 횟수: 6번

## LRU

Least Recently Used

가장 오래 사용되지 않은 페이지를 교체한다. \*시간 기준

> 너 너무 오랫동안 가만히 있었어! 안 쓸 거면 방 빼!

Recently를 보고 최근에 사용한 페이지를 유지하고 오래 가만히 있는 페이지를 교체한다고 생각하면 외우기 편하다.

Page Hit를 하면 해당 페이지는 다시 시간을 갱신시켜 주는 것이 특징이다.

3개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어있다고 가정한다. 다음과 같은 순서로 페이지 참조가 발생할 때, 페이지 교체 알고리즘으로 LRU(Least Recently Used)를 사용한다면 몇 번의 페이지 결함이 발생하는지 쓰시오. 페이지 참조 순서: 1, 2, 3, 1, 2, 4, 1, 2, 5, 4

[_ _ _]

[1(0) _ _] <- Page Fault (1)은 들어오고 경과된 시간을 기록하는 용도이다.

[1(1) 2(0) _] <- Page Fault

[1(2) 2(1) 3(0)] <- Page Fault

[1(0) 2(2) 3(1)] <- Hit! 1이 이미 있었어!

[1(1) 2(0) 3(2)] <- Hit!

[1(2) 2(1) 4(0)] <- Page Fault 3이 제일 오래됐으니까 교체

[1(0) 2(2) 4(1)] <- Page Hit

[1(1) 2(0) 4(2)] <- Page Hit

[1(2) 2(1) 5(0)] <- Page Fault

[2(2) 5(1) 4(0)] <- Page Fault

페이지 부재 횟수: 6번

## LFU

Least Frequently Used

가장 적게 사용된 걸 교체한다. \*횟수 기준

> 확률적으로 적게 사용되면 또 다시 사용할 일이 적어질 테니까 방 빼세요~

그리고 사용 빈도가 똑같으면 오래된 페이지를 빼주면 된다.

3개의 페이지 프레임으로 구성된 기억장치에서 다음과 같은 순서대로 페이지 요청이 일어날 때, 페이지 교체 알고리즘으로 LFU(Least Frequently Used)를 사용한다면 몇 번의 페이지 부재가 발생하는가? (단, 초기 페이지 프레임은 비어있다고 가정한다.)

요청된 페이지 번호의 순서: 2, 3, 1, 2, 1, 2, 4, 2, 1, 3, 2

[_ _ _]

[2(1) _ _] - Page Fault (1)은 해당 페이지 사용 횟수

[2(1) 3(1) _] - Page Fault

[2(1) 3(1) 1(1)] - Page Fault

[2(2) 3(1) 1(1)] - Page Hit!

[2(2) 3(1) 1(2)] - Page Hit!

[2(3) 3(1) 1(2)] - Page Hit!

[2(3) 1(2) 4(1)] - Page Fault (3번 페이지를 가지고 있는 프레임 분은 가장 적게 사용하셔서 교체되셨어요~)

[2(4) 1(2) 4(1)] - Page Hit!

[2(4) 1(3) 4(1)] - Page Hit!

[2(4) 1(3) 3(1)] - Page Fault

[2(5) 1(3) 3(1)] - Page Hit!

부재 횟수: 5번

> 근데 LFU 좀 이상해 보인다. 해당 프레임이 많이 사용되고 나중 가서 필요 없어질 때 다른 프레임들이 이 프레임 만큼이나 사용해야 교체할 수 있다는 말이 되는데 흠..

## LRU는 FIFO의 개선 버전

FIFO는 오래되면 그냥 방을 빼야했는데 LRU는 다시 사용될 때 갱신시켜주는 방식이다.
